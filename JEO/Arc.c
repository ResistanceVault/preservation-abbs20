;/*
sc5 -j73 -v Arc
copy Arc.c -J:Arc.c
slink LIB:c.o+"Arc.o" to Arc LIB LIB:sc.lib LIB:JEO.lib
copy Arc.c dabbs:JEO/
copy Arc dabbs:JEO/
quit
*/

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jan Erik Olausen
 */

#include <JEO:JEO.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <proto/dos.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/gadtools.h>
#include "dabbs:JEO/Arc.h"
#include <bbs.h>

VOID CleanUp (VOID);
int HandleMsg (struct ABBSmsg *msg);
BOOL	Setup (void);

UBYTE Dummy[5000];

struct List listheader;
static struct Node *list = NULL;

struct ConfigRecord *config;
struct ABBSmsg msg;
struct MsgPort *rport = NULL;
struct Library *UtilityBase = NULL;
struct RastPort *rp;

struct Screen         *Scr = NULL;
UBYTE                 *PubScreenName = 0; // "ABBS Screen";
APTR                   VisualInfo = NULL;
struct Window         *ArcWnd = NULL;
struct Gadget         *ArcGList = NULL;
struct Gadget         *ArcGadgets[1];
UWORD                  ArcLeft = 0;
UWORD                  ArcTop = 0;
UWORD                  ArcWidth = 640;
UWORD                  ArcHeight = 256;
UBYTE                 *ArcWdt = (UBYTE *)"Archivers config";

struct TextAttr topaz8 = {
	( STRPTR )"topaz.font", 8, 0x00, 0x01 };

UWORD ArcGTypes[] = {
	LISTVIEW_KIND
};

struct NewGadget ArcNGad[] = {
	156, 17, 184, 144, NULL, NULL, GD_Format, 0, NULL, NULL
};

ULONG ArcGTags[] = {
	(GTLV_ShowSelected), NULL, (TAG_DONE),
};

int SetupScreen( void )
{
	if ( ! ( Scr = LockPubScreen( PubScreenName )))
	{
		if ( ! ( Scr = LockPubScreen( NULL )))
			return( 1L );
	}

	if ( ! ( VisualInfo = GetVisualInfo( Scr, TAG_DONE )))
		return( 2L );

	return( 0L );
}

void CloseDownScreen( void )
{
	if ( VisualInfo ) {
		FreeVisualInfo( VisualInfo );
		VisualInfo = NULL;
	}

	if ( Scr        ) {
		UnlockPubScreen( NULL, Scr );
		Scr = NULL;
	}
}

int OpenArcWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		offx = Scr->WBorLeft, offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

	if ( ! ( g = CreateContext( &ArcGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < Arc_CNT; lc++ ) {

		CopyMem((char * )&ArcNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = &topaz8;
		ng.ng_LeftEdge  += offx;
		ng.ng_TopEdge   += offy;

		ArcGadgets[ lc ] = g = CreateGadgetA((ULONG)ArcGTypes[ lc ], g, &ng, ( struct TagItem * )&ArcGTags[ tc ] );

		while( ArcGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( ArcWnd = OpenWindowTags( NULL,
				WA_Left,	ArcLeft,
				WA_Top,		ArcTop,
				WA_Width,	ArcWidth,
				WA_Height,	ArcHeight + offy,
				WA_IDCMP,	LISTVIEWIDCMP|IDCMP_CLOSEWINDOW|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_SIZEGADGET|WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH,
				WA_Gadgets,	ArcGList,
				WA_Title,	ArcWdt,
				WA_ScreenTitle,	"GadToolsBox V2.0b © 1991-1993",
				WA_PubScreen,	Scr,
				WA_MinWidth,	67,
				WA_MinHeight,	21,
				WA_MaxWidth,	724,
				WA_MaxHeight,	283,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( ArcWnd, NULL );

	return( 0L );
}

void CloseArcWindow( void )
{
	if ( ArcWnd        ) {
		CloseWindow( ArcWnd );
		ArcWnd = NULL;
	}

	if ( ArcGList      ) {
		FreeGadgets( ArcGList );
		ArcGList = NULL;
	}
}

int SetupListView (void)
{
	static struct ueNode {
		struct Node node;
		char	Format[21];
	} *nodes;
	int	n, num;
//	struct Log_entry *logs;

	num = config->ActiveDirs;
	if (!(nodes = AllocVec (num * (sizeof (struct ueNode)), MEMF_CLEAR)))
		return (0);

	if (list)
		FreeVec (list);
	list = (struct Node *)nodes;

//	logs = (struct Log_entry *) Mainmem->LogTabelladr;
	NewList (&listheader);

	Forbid();

	for (n = 0; n < config->MaxfileDirs; n++)
	{
		if (*(config->firstFileDirRecord[n].n_DirName))
		{
			nodes[n].node.ln_Name = (char *)&config->firstFileDirRecord[n].n_DirName;
			strcpy (nodes[n].Format, config->firstFileDirRecord[n].n_DirName);
			AddTail (&listheader,&nodes[n].node);
		}
	}
	Permit();

	GT_SetGadgetAttrs (ArcGadgets[GD_Format], ArcWnd, NULL , GTLV_Labels, 
										 &listheader, TAG_DONE, NULL);

	return (1);
}

VOID UpdateDisplay (ULONG n)
{
	JEOWrite (rp, 20, 180, "                                               ", 1);
	JEOWrite (rp, 20, 180, config->firstFileDirRecord[n].n_DirName, 1);

	JEOWrite (rp, 20, 188, "                                               ", 1);
	JEOWrite (rp, 20, 188, config->firstFileDirRecord[n].n_DirPaths, 1);

	sprintf (Dummy, "Order: %3ld    PTC: %3ld", config->firstFileDirRecord[n].n_FileOrder, 
                                              config->firstFileDirRecord[n].n_PrivToConf);
	JEOWrite (rp, 20, 196, Dummy, 1);
}

BOOL handleidcmp (void)
{
	struct IntuiMessage	*m;
	BOOL	running = TRUE;
	int	n;
	UWORD	code;
	struct IntuiMessage	tmpmsg;
	struct Node *node;
	struct MenuItem		*mi;

	while (m = GT_GetIMsg (ArcWnd->UserPort))
	{
		CopyMem ((char *) m, (char *) &tmpmsg, (long) sizeof(struct IntuiMessage));
		GT_ReplyIMsg(m);

		switch (tmpmsg.Class)
		{
/*
			case	IDCMP_REFRESHWINDOW:
				GT_BeginRefresh (ArcWnd);
				ArcRender();
				GT_EndRefresh (ArcWnd,TRUE);
				break;
*/
/*
			case	IDCMP_MENUPICK:
				code = tmpmsg.Code;
				while (code != MENUNULL)
				{
					switch (MENUNUM(code))
					{
						case 0:
						{
							switch (ITEMNUM(code))
							{
								case 0:
									EasyRequestArgs(ArcWnd,&aboutereq,NULL,NULL);
									break;
								case 1:
									dosaveuser();
									break;
								case 3:
								}
							}
							break;
					}

					mi = ItemAddress(ArcMenus,code);
					code = mi->NextSelect;
				}
				break;

*/
			case	IDCMP_CLOSEWINDOW:
				running = FALSE;
				break;

			case	IDCMP_GADGETUP:
			{
				switch (((struct Gadget *) tmpmsg.IAddress)->GadgetID)
				{
					case GD_Format:
						node = listheader.lh_Head;
						for (n = 0; n < tmpmsg.Code; n++)
							node = node->ln_Succ;
						UpdateDisplay (n);
						break;

				}
				break;
			}
		}
	}
	return (running);
}

VOID CleanUp (VOID)
{
	if (ArcWnd)
		CloseArcWindow ();
	CloseDownScreen ();

	if (msg.msg.mn_ReplyPort)
		DeleteMsgPort(msg.msg.mn_ReplyPort);
	if (UtilityBase)
		CloseLibrary (UtilityBase);

	exit (0);
}

BOOL Setup (void)
{
	BOOL ret = FALSE;

	if (FindPort (MainPortName))
	{
		if (UtilityBase = OpenLibrary ("utility.library",36))
		{
			if (msg.msg.mn_ReplyPort = CreateMsgPort())
			{
				msg.Command = Main_Getconfig;
				if (HandleMsg (&msg) || !msg.UserNr)
					printf ("Error talking to ABBS\n");
				else
				{
					config = (struct ConfigRecord *)msg.Data;
					ret = TRUE;
				}
			}
			else
				printf ("Error creating message port\n");
		}
		else
			printf ("Error opening utility.library\n");
	}
	else
		printf ("ABBS must be running for Arc to work\n");

	return (ret);
}

int HandleMsg (struct ABBSmsg *msg)
{
	struct MsgPort *mainport, *inport;
	struct ABBSmsg *inmsg;
	int	ret;

	inport = msg->msg.mn_ReplyPort;
	Forbid();
	if (mainport = FindPort(MainPortName))
	{
		PutMsg (mainport, (struct Message*)msg);
		Permit ();
		while (1)
		{
			if (!WaitPort(inport))
				continue;

			if (inmsg = (struct ABBSmsg *)GetMsg (inport))
				break;
		}
		ret = inmsg->Error;
	}
	else
	{
		Permit ();
		ret = Error_NoPort;
	}

	return (ret);
}

main ()
{
	int	ret = 0;
	int	quit = 1;
	ULONG	waitsigs,gotsigs;

	if (!Setup ())
		CleanUp ();

	if (SetupScreen ())
		CleanUp ();
	if (OpenArcWindow ())
		CleanUp ();

  rp = ArcWnd->RPort;

	waitsigs = ((1L << ArcWnd->UserPort->mp_SigBit) | SIGBREAKF_CTRL_C);
//	memcpy (&curuserback,&curuser,sizeof (struct UserRecord));

	if (SetupListView ())
		quit = 0;
	while (!quit)
	{
		gotsigs = Wait (waitsigs);
		quit = (!(handleidcmp()));
		if (gotsigs & SIGBREAKF_CTRL_C)
			quit = 1;
	}

	CleanUp ();
}
