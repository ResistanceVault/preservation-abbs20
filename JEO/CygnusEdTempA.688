;/*
sc5 -j73 -v FileEditor
copy FileEditor.c -J:FileEditor.c
slink LIB:c.o+"FileEditor.o" to FileEditor LIB LIB:sc.lib LIB:JEO.lib
quit
*/

/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jan Erik Olausen
 */

#include <JEO:JEO.h>
#include <exec/memory.h>
#include <exec/execbase.h>
#include <exec/lists.h>
#include <proto/dos.h>
#include <proto/intuition.h>
#include <proto/graphics.h>
#include <proto/gadtools.h>
#include "dabbs:JEO/FileEditor_MUI.c"
#include <bbs.h>

#define GREY	0
#define BLACK	1
#define WHITE	2
#define BLUE	3

VOID CleanUp (VOID);
int HandleMsg (struct ABBSmsg *msg);
BOOL	Setup (void);

WORD nr_1, nr_2;

UBYTE Dummy[5000];

struct List listheader;
static struct Node *list = NULL;

struct ConfigRecord *config;
struct ABBSmsg msg;
struct MsgPort *rport = NULL;
struct Library *UtilityBase = NULL;

// *********************************************************************
// ***********************  fileentry lists ****************************
// *********************************************************************

ULONG recCount;

typedef struct
{
  struct List list;
  ULONG howmany;
} Sjef;

Sjef sjef;

typedef struct
{
  struct Node nd;
  struct Fileentry fentry;
	ULONG fentry_order;
} Base;

VOID KillBase (VOID)
{
  ULONG s;
  struct Node *nd;

  nd = sjef.list.lh_Head;
  for (s = 0; s < recCount; s++)
  {
    Remove (nd);
    FreeMem ((UBYTE *)nd, sizeof (Base));
    nd = 0;
    nd = sjef.list.lh_Head;
  }
  recCount = 0;
}

VOID CloseBase (VOID)
{
  Base *bp;

  if (recCount > 0)
  {
	  KillBase ();
	  bp = (Base *)sjef.list.lh_Head;
  	while (bp = RemHead (&sjef.list))
	  {
  	  FreeMem (bp, sizeof (Base));
    	bp = 0;
    }
  }
}

struct Node *FindTheOne (UBYTE *Name)
{
  register struct Node *nd;

  nd = sjef.list.lh_Head;
  while (nd->ln_Succ)
  {
    if (stricmp (nd->ln_Name, Name) > 0)
    {
      nd = nd->ln_Pred;
      return (nd);
    }
    nd = nd->ln_Succ;
  }
  return (FALSE);
}

BOOL InsertBase (struct Fileentry fentry, ULONG k)
{
  Base *bp=NULL;
//  struct Node *nd;

  if (!(bp = (Base *)AllocMem (sizeof (Base), MEMF_PUBLIC)))
    return (FALSE);

  if (AvailMem (MEMF_CHIP) < (60 * 1024))
    return (FALSE);

  CopyMem (&fentry, &bp->fentry, sizeof (struct Fileentry));
	bp->fentry_order = k;
  bp->nd.ln_Name=bp->fentry.Filename;
	AddTail (&sjef.list, &bp->nd);	// Alltid add her, ikke insert (sort)

  recCount++;
  return (TRUE);
}

BOOL DeleteOne (UBYTE *Name)
{
  register struct Node *nd;

  if (nd = FindName (&sjef.list, Name)) 
  {
    Remove (nd);
    FreeMem ((UBYTE *)nd, sizeof (Base));
    nd = 0;
    recCount--;
    return (TRUE);
  }
  else
    return (FALSE);
}

BOOL HandleEditIDCMP (void)
{
	struct IntuiMessage	*m;
	int	n;
	UWORD	code;
 	ULONG class;
	struct IntuiMessage	tmpmsg;
	struct MenuItem *mi;
  BOOL ret = TRUE;

	while (m = GT_GetIMsg (EditWnd->UserPort))
	{
		CopyMem ((char *)m, (char *)&tmpmsg, (long)sizeof(struct IntuiMessage));
		GT_ReplyIMsg (m);
		code = tmpmsg.Code;
		class = tmpmsg.Class;
		switch (tmpmsg.Class)
		{
			case	IDCMP_CLOSEWINDOW:
				ret = FALSE;
				break;

			case	IDCMP_GADGETUP:
				switch (((struct Gadget *) tmpmsg.IAddress)->GadgetID)
				{
				}
		}
	}
	return (ret);
}

BOOL GetUser (ULONG nr, UBYTE *User)
{
	struct UserRecord ur;
	int err;

	msg.Command = Main_loadusernr;
	msg.UserNr = nr;
	msg.Data = (ULONG)&ur;
	err = HandleMsg (&msg);
	if (err != Error_OK)
		return (FALSE);

	strcpy (User, ur.Name);
	return (TRUE);
}

VOID Edit_file (struct Fileentry fentry, ULONG o)
{
	ULONG	waitsigs, gotsigs;
	BOOL quit = 1;
	struct RastPort *rp;
	WORD x, y;
	UWORD conf_order, n;
	struct ConferenceRecord *confarray;

	if (!(OpenEditWindow ()))
	{
		confarray = (struct ConferenceRecord *) 
				(((int) config) + (SIZEOFCONFIGRECORD));

		rp = EditWnd->RPort;
//		printf ("Filename: %-18s %-36s\n", fentry.Filename, fentry.Filedescription);
		x = 20;
		y = 120;
		JEOWrite (rp, x, y,      " Downloads:", BLACK);
		JEOWrite (rp, x, y += 8, "      Size:", BLACK);
		JEOWrite (rp, x, y += 8, "      Date:", BLACK);
		JEOWrite (rp, x, y += 8, "      From:", BLACK);
		JEOWrite (rp, x, y += 8, "        To:", BLACK);
		JEOWrite (rp, x, y += 8, "Conference:", BLACK);

		x = 20 + (12 * 8);
		y = 120;
		sprintf (Dummy, "%ld", fentry.AntallDLs);
		JEOWrite (rp, x, y, Dummy, WHITE);

		sprintf (Dummy, "%ld bytes (%ld Kb)", fentry.Fsize, fentry.Fsize / 1024);
		JEOWrite (rp, x, y += 8, Dummy, WHITE);

		sprintf (Dummy, "%ld", fentry.ULdate);
		JEOWrite (rp, x, y += 8, Dummy, WHITE);

		GetUser (fentry.Uploader, Dummy);		// Hente bruker
		JEOWrite (rp, x, y += 8, Dummy, WHITE);

		if (fentry.Filestatus & FILESTATUSF_PrivateUL)	// Privat?
			GetUser (fentry.PrivateULto, Dummy);		// Hente bruker
		else
			strcpy (Dummy, "ALL");
		JEOWrite (rp, x, y += 8, Dummy, WHITE);

		if (fentry.Filestatus & FILESTATUSF_PrivateConfUL)	// Privat til konf?
		{
			conf_order = fentry.PrivateULto/2 + 1;
			for (n = 0; n < config->Maxconferences; n++)
			{
				if (confarray[n].n_ConfOrder == conf_order)
					break;
			}
			sprintf (Dummy, "%s", confarray[n].n_ConfName);
		}
		else
			strcpy (Dummy, "N/A");
		JEOWrite (rp, x, y += 8, Dummy, WHITE);

		waitsigs = (1L << EditWnd->UserPort->mp_SigBit);
		while (quit)
		{
			gotsigs = Wait (waitsigs);
			quit = HandleEditIDCMP ();
		}

		if (EditWnd)
			CloseEditWindow ();
	}
}

// ***********************************************************************
// **************************** SetupDirs ********************************
// ***********************************************************************

BOOL SetupDirs (VOID)
{
	static struct ueNode
	{
		struct Node node;
//		char Path[31];
	} *nodes;
	int	n, num;

	num = config->ActiveDirs;
	if (!(nodes = AllocVec (num * (sizeof (struct ueNode)), MEMF_CLEAR)))
		return (FALSE);

	if (list)
		FreeVec (list);
	list = (struct Node *)nodes;
	NewList (&listheader);

	Forbid();

	for (n = 0; n < config->MaxfileDirs; n++)
	{
		if (*(config->firstFileDirRecord[n].n_DirName))
		{
			nodes[n].node.ln_Name = (char *)&config->firstFileDirRecord[n].n_DirName;
//			strcpy (nodes[n].Path, config->firstFileDirRecord[n].n_DirPath);
			AddTail (&listheader,&nodes[n].node);
		}
	}
	Permit();

	GT_SetGadgetAttrs (FileEditorGadgets[GD_LIST_1], FileEditorWnd, NULL , GTLV_Labels, 
										 &listheader, TAG_DONE, NULL);
	return (TRUE);
}

// ***********************************************************************
// **************************** SetupFiles *******************************
// ***********************************************************************

BOOL SetupFiles (VOID)
{
	UBYTE FentryFName[80];
	ULONG o, k;
	int err;
	struct Fileentry fentry;
	int	num, size;

	if (recCount != 0)
		KillBase ();

	GT_SetGadgetAttrs (FileEditorGadgets[GD_LIST_2], FileEditorWnd, NULL , GTLV_Labels, 
										 NULL, TAG_DONE, NULL);

	sprintf (FentryFName, "ABBS:Conferences/%s.fl", config->firstFileDirRecord[nr_1].n_DirName);
	size = FileSize (FentryFName);
	if (size > 0)
	{
		num = size / sizeof (struct Fileentry);
		o = config->firstFileDirRecord[nr_1].n_FileOrder;
		Forbid ();
		for (k = 1;; k++)
		{
			msg.Command = Main_loadfileentry;
			msg.UserNr = o - 1;
			msg.arg = k;
			msg.Data = (ULONG)&fentry;
			err = HandleMsg (&msg);
			if (err == Error_EOF)
				break;
			if (err != Error_OK)
			{
				printf ("Error reading fileentry\n");
				break;
			}
			if (fentry.Filestatus & (FILESTATUSF_Filemoved | FILESTATUSF_Fileremoved))
				continue;

	    if (!(InsertBase (fentry, k)))
	    {
	    	printf ("Error memory...\n");
	    	CleanUp ();
	    }
		}
		Permit();
		GT_SetGadgetAttrs (FileEditorGadgets[GD_LIST_2], FileEditorWnd, NULL , GTLV_Labels, 
											 &sjef.list.lh_Head, TAG_DONE, NULL);
	}
	return (TRUE);
}

VOID handleidcmp (void)
{
	struct IntuiMessage	*m;
	int	n;
	UWORD	code;
 	ULONG class;
	struct IntuiMessage	tmpmsg;
	struct Node *node;
	struct MenuItem *mi;
  struct Node *nd;
  Base *bp;

	while (m = GT_GetIMsg (FileEditorWnd->UserPort))
	{
		CopyMem ((char *)m, (char *)&tmpmsg, (long)sizeof(struct IntuiMessage));
		GT_ReplyIMsg (m);
		code = tmpmsg.Code;
		class = tmpmsg.Class;
		switch (tmpmsg.Class)
		{
			case	IDCMP_MENUPICK:
			{
				while (code != MENUNULL)
				{
					switch (MENUNUM (code))
					{
						case 0:		// Project
						{
							switch (ITEMNUM (code))
							{
								case 5:	// Quit
									CleanUp ();
									break;
							}
							break;
						}
					}
					mi = ItemAddress (FileEditorMenus,code);
					code = mi->NextSelect;
				}
				break;
			}
			case	IDCMP_CLOSEWINDOW:
				CleanUp ();
				break;

			case	IDCMP_GADGETUP:
			{
				switch (((struct Gadget *) tmpmsg.IAddress)->GadgetID)
				{
					case GD_LIST_1:
						node = listheader.lh_Head;
						for (n = 0; n < tmpmsg.Code; n++)
							node = node->ln_Succ;
						nr_1 = n;
						SetupFiles ();
						break;
					case GD_LIST_2:
					  nd = sjef.list.lh_Head;
						for (n = 0; n < tmpmsg.Code; n++)
					    nd = nd->ln_Succ;
						bp = (Base *)nd;
						nr_2 = n;
						Edit_file (bp->fentry, bp->fentry_order);
						break;
				}
				break;
			}
		}
	}
}

VOID CleanUp (VOID)
{
	CloseBase ();
	if (FileEditorWnd)
		CloseFileEditorWindow ();
	CloseDownScreen ();

	if (msg.msg.mn_ReplyPort)
		DeleteMsgPort(msg.msg.mn_ReplyPort);
	if (UtilityBase)
		CloseLibrary (UtilityBase);

	exit (0);
}

BOOL Setup (void)
{
	BOOL ret = FALSE;

	nr_1 = nr_2 = -1;
	if (FindPort (MainPortName))
	{
		if (UtilityBase = OpenLibrary ("utility.library",36))
		{
			if (msg.msg.mn_ReplyPort = CreateMsgPort())
			{
				msg.Command = Main_Getconfig;
				if (HandleMsg (&msg) || !msg.UserNr)
					printf ("Error talking to ABBS\n");
				else
				{
					config = (struct ConfigRecord *)msg.Data;
					ret = TRUE;
				}
			}
			else
				printf ("Error creating message port\n");
		}
		else
			printf ("Error opening utility.library\n");
	}
	else
		printf ("ABBS must be running for FileEditor to work\n");

	return (ret);
}

int HandleMsg (struct ABBSmsg *msg)
{
	struct MsgPort *mainport, *inport;
	struct ABBSmsg *inmsg;
	int	ret;

	inport = msg->msg.mn_ReplyPort;
	Forbid();
	if (mainport = FindPort(MainPortName))
	{
		PutMsg (mainport, (struct Message*)msg);
		Permit ();
		while (1)
		{
			if (!WaitPort(inport))
				continue;

			if (inmsg = (struct ABBSmsg *)GetMsg (inport))
				break;
		}
		ret = inmsg->Error;
	}
	else
	{
		Permit ();
		ret = Error_NoPort;
	}

	return (ret);
}

main ()
{
	ULONG	waitsigs, gotsigs;

	if (!Setup ())
		CleanUp ();

	if (SetupScreen ())
		CleanUp ();
	if (OpenFileEditorWindow ())
		CleanUp ();

	waitsigs = ((1L << FileEditorWnd->UserPort->mp_SigBit) | SIGBREAKF_CTRL_C);
//	memcpy (&curuserback,&curuser,sizeof (struct UserRecord));

	SetupDirs ();
  NewList (&sjef.list);
  recCount = 0;
	FOREVER
	{
		gotsigs = Wait (waitsigs);
		handleidcmp ();
	}
}
